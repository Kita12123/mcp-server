# アーキテクチャ概要

このドキュメントは、本MCPサーバーのアーキテクチャ（設計思想と全体構造）を説明するものです。

## 1. アプリケーション概要

このアプリケーションは、ClineからRedmineやGitHubといった外部サービスを、**ユーザーそれぞれの権限で**操作するためのMCPサーバーです。

主な設計目標は、将来的な機能追加や仕様変更に柔軟に対応できるよう、**拡張性**と**保守性**を高く保つことです。そのために、以下で説明する「関心の分離」と「動的な認証」の原則に基づいたアーキテクチャを採用しています。

## 2. ディレクトリ構造

本プロジェクトは、機能の役割に応じてファイルを明確に分離したディレクトリ構造を採用しています。

```
mcp-server/
├── doc/               # ドキュメント類
├── dist/              # コンパイル後のJavaScriptファイルが出力されるディレクトリ
├── node_modules/      # 依存ライブラリ
├── src/               # ソースコード
│   ├── index.ts       # MCPサーバーのエントリーポイント
│   ├── tools/         # ツール定義を格納するディレクトリ
│   │   ├── redmine.ts   # Redmine関連のツール
│   │   └── github.ts    # GitHub関連のツール
│   └── lib/           # 外部APIクライアントなどを格納するディレクトリ
│       ├── api/
│       │   ├── redmine.ts   # Redmine APIクライアント
│       │   └── github.ts    # GitHub APIクライアント
│       └── core/
│           ├── apiClient.ts # 共通のAPIクライアントクラス
│           └── credentialManager.ts # 認証情報管理
├── .env               # 環境変数ファイル (Git管理外)
├── .env.example       # 環境変数のテンプレート
├── package.json
└── tsconfig.json
```

### 各ディレクトリの役割

#### `src/tools`

Clineに公開する「ツール」の定義を記述します。

-   **役割**: MCPサーバーにどのようなツール（機能）を、どのような名前・説明・入力パラメータで公開するかを定義することに特化します。
-   **実装**: ツールの具体的な処理は後述の`lib`に実装されたクライアントを呼び出す形にし、ここではそのインターフェース定義に集中します。

#### `src/lib`

外部サービスとの通信など、具体的な処理ロジックを実装します。

-   **`src/lib/core/apiClient.ts`**:
    -   **役割**: RedmineやGitHubなど、複数のAPIで共通して利用できる、HTTP通信のコア機能を提供します。GET/POSTリクエスト、ヘッダー設定、エラーハンドリングといった汎用的な処理をこの基底クラスに集約しています。
    -   **メリット**: コードの重複を排除し、通信部分の修正（タイムアウト設定など）が必要になった場合に、このファイル一箇所を修正するだけで済むようになります。

-   **`src/lib/api/`**:
    -   **役割**: `apiClient.ts`を継承し、RedmineやGitHubといった各サービス固有のクライアントを実装します。このクライアントは、ツール実行時にユーザーごとのAPIキーを使って**動的に生成**されます。
    -   **メリット**: サービスごとのAPIロジックがカプセル化されるため、見通しが良くなり、API仕様の変更にも対応しやすくなります。

-   **`src/lib/core/credentialManager.ts`**:
    -   **役割**: ユーザー（セッション）ごとのAPIキーを安全に管理します。ツール実行時にAPIキーが設定されているかを確認し、なければ後述の`Elicitation`機能の呼び出しをトリガーします。

### 設計のポイント

#### 関心の分離

`tools`と`lib`を分離し、さらに`lib`を`core`と`api`に分離しているのは、**「関心の分離 (Separation of Concerns)」** という設計原則に基づいています。

-   「Clineにどう見せるか」（`tools`）
-   「外部サービスとどう通信するか」（`lib`）

この２つの関心事を分離することで、片方の変更がもう片方に影響を与えにくくなります。例えば、ツールの説明文を変更したいだけの場合に、API通信の複雑なロジックを気にする必要はありません。

#### 動的な認証とElicitation

本サーバーは、ユーザーごとにパーソナライズされた操作を実現するため、動的な認証機構を備えています。

-   **ワークフロー**:
    1.  ユーザーがツールを実行します。
    2.  サーバーは`credentialManager`に、このユーザー用のAPIキーが設定済みか問い合わせます。
    3.  キーが未設定の場合、サーバーはMCPの**Elicitation（入力要求）**機能を使って、ClineのUIに安全な入力ボックスを表示させ、ユーザーにキーの入力を促します。
    4.  ユーザーが入力したキーは`credentialManager`に保存され、そのキーを使ってAPIクライアントが動的に生成され、処理が実行されます。

-   **メリット**:
    -   **セキュリティ**: APIキーのような機密情報がプロンプト履歴に残らず、安全に扱われます。
    -   **UX**: ユーザーは必要なタイミングで自然にキーを入力でき、一度設定すればセッション中は再入力が不要です。

この設計により、将来的に「Jiraを追加したい」「Slack通知機能を追加したい」といった場合にも、既存のコードに大きな変更を加えることなく、新しいファイルを`tools`と`lib/api`に追加するだけで、安全かつ簡単に対応できます。

## 3. 本番環境へのデプロイ

本サーバーは、AWSなどのクラウド環境で複数のユーザーが利用することを想定しています。

### 考慮事項：認証情報の永続化

現在の`credentialManager`は、ユーザーのAPIキーをサーバーのメモリ上にセッション情報として保持します。これは単一インスタンスでの運用やローカル開発では問題ありません。

しかし、AWS FargateやLambdaのように、複数のインスタンスが起動する可能性のあるスケーラブルな環境にデプロイする場合、リクエストごとに異なるインスタンスに振り分けられる可能性があります。その場合、メモリ上のセッション情報は引き継がれません。

この問題に対応するため、本番環境では認証情報を以下のような外部の永続的なストレージに保存する実装の追加を検討する必要があります。

-   **データベース (例: DynamoDB)**
-   **インメモリキャッシュ (例: ElastiCache for Redis)**

これにより、どのサーバーインスタンスがリクエストを処理しても、ユーザーの認証情報を一貫して参照できるようになります。

## 4. 技術選定の理由

このMCPサーバーは**TypeScript**で実装されています。

主な理由は、ClineとMCPサーバー間の通信を容易に実現するための公式ライブラリ（`@modelcontextprotocol/sdk`）が、現在TypeScript（JavaScript）向けにのみ提供されているためです。

このSDKを利用することで、開発者はClineとの複雑な通信プロトコルを意識することなく、ツールのコアな機能（例えば、Redmine APIを呼び出す処理など）の実装に集中できます。

将来的にもしPythonなど他の言語向けの公式SDKが提供された場合は、その言語への移行も検討可能です。
